<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Switch 'n Slide</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>Switch 'n Slide</h1>

    <div class="level-selector">
      <strong>Level:</strong>
      <label><input type="radio" name="level" value="1" onclick="setupGame(1)" checked> 1</label>
      <label><input type="radio" name="level" value="2" onclick="setupGame(2)"> 2</label>
      <label><input type="radio" name="level" value="3" onclick="setupGame(3)"> 3</label>
      <label><input type="radio" name="level" value="4" onclick="setupGame(4)"> 4</label>
      <label><input type="radio" name="level" value="5" onclick="setupGame(5)"> 5</label>
    </div>

    <p id="goal">Goal: Define rules that slide the tape exactly N times.</p>

    <div class="rules-container">
      <div class="rule-header">Rules:</div>
      <div id="rules"></div>
    </div>

    <div class="controls">
      <button onclick="runMachine()">Begin</button>
    </div>

    <div id="result"></div>
    <div class="step-counter">Slides: <span id="stepCount">0</span></div>
    <div class="state-indicator">Current Mode: <span id="currentState" class="current-state">A</span></div>

    <div id="tape">
        <div id="tape-container" class="tape-container">
          <div id="tape-wrapper" class="tape-wrapper">
            <div id="tape-inner" class="tape-inner"></div>
          </div>
        </div>
    </div>
    </div>

    <script>
      // --- Game Configuration ---
      let numStates = 2;
      let states = ['A', 'B'];
      let nextStateOptionsText = ['Yes', 'No', 'Stop'];
      let targetSteps = 2; // Default for new Level 1 (level 1 + 1)
      let currentLevel = 1; // Default to new Level 1
  
      const symbols = ['O', 'X'];
      const moveOptions = ['Left', 'Right']; // Not directly used for button cycle anymore for fixed ones
      const cellWidth = 28;
      const cellMargin = 2;
      const cellTotalWidth = cellWidth + cellMargin;
  
      let isRunning = false;
      let machineTimeout = null;
      let currentTape = {};
      let currentHeadPosition = 0;
  
      function setupGame(level) {
          stopMachine();
          currentLevel = level;
          targetSteps = level + 1; // New Level 1 -> 2 slides, Level 2 -> 3 slides, etc.
  
          const goalText = document.getElementById('goal');
          goalText.innerHTML = `Goal: Define rules that slide the tape exactly ${targetSteps} time${targetSteps !== 1 ? 's' : ''}.<br>The tape will be marked with X as you slide past.`;
  
          buildUI();
          initializeTape();
          resetMachine();
      }
  
      function buildUI() {
        const container = document.getElementById('rules');
        container.innerHTML = '';
  
        for (const state of states) {
          for (const symbol of symbols) {
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'rule';
  
            const ruleLabel = document.createElement('div');
            ruleLabel.className = 'rule-label';
            ruleLabel.textContent = `If Mode is ${state} and Tape is ${symbol}:`;
            ruleDiv.appendChild(ruleLabel);
  
            ruleDiv.appendChild(document.createTextNode("Slide "));
  
            const moveBtn = document.createElement('button');
            moveBtn.id = `${state}${symbol}-move`;
            ruleDiv.appendChild(moveBtn);
  
            ruleDiv.appendChild(document.createTextNode(" Switch Mode? "));
  
            const nextBtn = document.createElement('button');
            nextBtn.id = `${state}${symbol}-next`;
            ruleDiv.appendChild(nextBtn);

            if (state === 'A' && symbol === 'O') {
                // Hardcoded rule: Mode A, Tape O -> Move Left, Switch Mode (Yes)
                moveBtn.textContent = 'Left';
                moveBtn.disabled = true;
                nextBtn.textContent = 'Yes';
                nextBtn.disabled = true;
            } else if (state === 'B' && symbol === 'O') {
                // Partially fixed rule: Mode B, Tape O -> Move Right (fixed), Switch Mode (editable)
                moveBtn.textContent = 'Right';
                moveBtn.disabled = true;

                // Switch Mode button remains editable for B/O
                let nextIndex = 0; // Default to 'Yes' for B/O's switch option
                nextBtn.textContent = nextStateOptionsText[nextIndex];
                nextBtn.onclick = () => {
                    nextIndex = (nextIndex + 1) % nextStateOptionsText.length;
                    nextBtn.textContent = nextStateOptionsText[nextIndex];
                };
            } else {
                // Default setup for other fully editable rules
                moveBtn.textContent = 'Left'; // Default move
                moveBtn.onclick = () => {
                    moveBtn.textContent = moveBtn.textContent === 'Left' ? 'Right' : 'Left';
                };

                let nextIndex = 0; // Default to 'Yes'
                nextBtn.textContent = nextStateOptionsText[nextIndex];
                nextBtn.onclick = () => {
                    nextIndex = (nextIndex + 1) % nextStateOptionsText.length;
                    nextBtn.textContent = nextStateOptionsText[nextIndex];
                };
            }
            container.appendChild(ruleDiv);
          }
        }
      }
  
      function getRule(state, symbol) {
        if (state === 'A' && symbol === 'O') {
          return { write: 'X', move: 'Left', next: 'B' }; // 'B' is the state after 'A'
        } else if (state === 'B' && symbol === 'O') {
          // Mode B, Tape O: Move is fixed to Right, Next is determined by its button
          const nextEl = document.getElementById(`BO-next`);
          if (!nextEl) {
            console.error(`Rule element BO-next not found`);
            return { write: 'X', move: 'Right', next: state }; // Fallback
          }
          let nextValText = nextEl.textContent;
          let resolvedNext;
          if (nextValText === 'Stop') {
            resolvedNext = 'Stop';
          } else if (nextValText === 'Yes') {
            resolvedNext = state === 'A' ? 'B' : 'A'; // If current is B, switch to A
          } else { // 'No'
            resolvedNext = state; // Stay in B
          }
          return { write: 'X', move: 'Right', next: resolvedNext };
        }

        // For fully editable rules
        const moveEl = document.getElementById(`${state}${symbol}-move`);
        const nextEl = document.getElementById(`${state}${symbol}-next`);
  
        if (!moveEl || !nextEl) {
            console.error(`Rule elements not found for state ${state}, symbol ${symbol}`);
            return { write: 'X', move: 'Right', next: state }; 
        }
  
        let nextValText = nextEl.textContent;
        let resolvedNext;
  
        if (nextValText === 'Stop') {
            resolvedNext = 'Stop';
        } else if (nextValText === 'Yes') {
            resolvedNext = state === 'A' ? 'B' : 'A';
        } else { // 'No'
           resolvedNext = state;
        }
  
        return { write: 'X', move: moveEl.textContent, next: resolvedNext };
      }

    // --- Tape Visualization ---
    function initializeTape() {
      const tapeContainer = document.getElementById('tape-container');
      const tapeWrapper = document.getElementById('tape-wrapper');
      const tapeInner = document.getElementById('tape-inner');

      if (!tapeContainer || !tapeWrapper || !tapeInner) {
          console.error("Tape elements not found during initialization!");
          return;
      }

      tapeInner.innerHTML = '';
      tapeInner.style.transform = 'translateX(0px)';

      const currentTargetSteps = Math.max(1, targetSteps); // Ensure at least 1 for calculation
      const numVisibleCells = 2 * currentTargetSteps + 1; // e.g. targetSteps=2 -> 5 cells
      const tapeWidth = numVisibleCells * cellTotalWidth;

      tapeContainer.style.width = `${tapeWidth}px`;
      tapeWrapper.style.width = `${tapeWidth}px`;

      for (let i = 0; i < numVisibleCells; i++) {
        const cell = document.createElement('span');
        cell.className = 'cell';
        cell.textContent = 'O';
        cell.setAttribute('data-index', i - currentTargetSteps); // Center index around 0
        tapeInner.appendChild(cell);
      }
    }

    function updateTape(tape, headPosition) {
        const tapeWrapper = document.getElementById('tape-wrapper');
        const tapeInner = document.getElementById('tape-inner');

        if (!tapeWrapper || !tapeInner) {
          console.error("Tape elements not found during update!");
          return;
        }
        const cells = tapeInner.querySelectorAll('.cell');
        if (cells.length === 0) {
            console.error("No cells found to update!");
            return;
        }

        const tapeWidth = parseFloat(tapeWrapper.style.width);
        const visualCenter = tapeWidth / 2;
        
        const centerDataIndex = 0; // The logical center of our tape data
        // Find the DOM element that corresponds to the logical center data index, if it exists.
        // Or more simply, the middle DOM element.
        const centerCellDOMIndex = Math.floor(cells.length / 2);


        cells.forEach(cell => {
            cell.classList.remove('active');
            const logicalIndex = parseInt(cell.getAttribute('data-index'));
            const value = tape[logicalIndex] || 'O';
            cell.textContent = value;
        });

        let activeCellDOMIndex = -1;
        for (let i = 0; i < cells.length; i++) {
            const logicalIndex = parseInt(cells[i].getAttribute('data-index'));
            if (logicalIndex === headPosition) {
                cells[i].classList.add('active');
                activeCellDOMIndex = i;
                break;
            }
        }
        
        if (activeCellDOMIndex !== -1) {
            // Center based on the DOM position of the active cell
            const activeCellVisualCenter = activeCellDOMIndex * cellTotalWidth + (cellTotalWidth / 2);
            const offset = visualCenter - activeCellVisualCenter;
            tapeInner.style.transform = `translateX(${offset}px)`;
        } else {
            // Fallback: if active cell is not currently rendered (e.g. head moved off initial display)
            // This attempts to keep the tape somewhat centered based on headPosition's logical relation to the center.
            // This case implies the head is "off-screen" relative to current DOM cells.
            // A more robust solution for infinite tapes would dynamically add/remove cells.
            // For this game, headPosition should ideally stay within view based on targetSteps.
            const offsetBasedOnHead = visualCenter - ( (headPosition + centerCellDOMIndex - parseInt(cells[centerCellDOMIndex].getAttribute('data-index'))) * cellTotalWidth + (cellTotalWidth / 2) );
            tapeInner.style.transform = `translateX(${offsetBasedOnHead}px)`;
        }
    }

    // --- Machine Control ---
    function stopMachine() {
         if (machineTimeout) {
            clearTimeout(machineTimeout);
            machineTimeout = null;
         }
         isRunning = false;
    }

    function resetMachine() {
      stopMachine();
      currentTape = {};
      currentHeadPosition = 0;

      document.getElementById('currentState').textContent = 'A';
      document.getElementById('result').textContent = '';
      document.getElementById('result').className = '';
      document.getElementById('stepCount').textContent = '0';

      // initializeTape is called by setupGame. updateTape will render the reset state.
      if (document.getElementById('tape-inner')?.children.length > 0) {
           updateTape(currentTape, currentHeadPosition);
      } else {
           // This case should ideally not be hit if setupGame runs first
           initializeTape(); 
           setTimeout(() => updateTape(currentTape, currentHeadPosition), 0);
      }
    }

    function runMachine() {
      if (isRunning) return;
      // resetMachine() is implicitly called via setupGame() before a new run.
      isRunning = true;

      let tape = { ...currentTape }; 
      let headPosition = currentHeadPosition; 
      let state = 'A'; 
      let steps = 0;
      const maxSteps = targetSteps; 

      document.getElementById('currentState').textContent = state;
      document.getElementById('stepCount').textContent = steps;
      updateTape(tape, headPosition); 

      function step() {
        if (!isRunning) return;
        const result = document.getElementById('result');

        if (state === 'Stop') {
            if (steps === maxSteps) {
                result.textContent = `Success! You slid exactly ${steps} time${steps !== 1 ? 's' : ''}.`;
                result.className = 'success';
            } else { 
                 result.textContent = `Fail! You stopped at ${steps} slide${steps !== 1 ? 's' : ''}. Goal was ${maxSteps}.`;
                 result.className = 'failure';
            }
            stopMachine();
            return;
        }

        if (steps >= maxSteps) { 
            result.textContent = `Fail! You slid ${steps} times (max ${maxSteps}) without stopping correctly.`;
            result.className = 'failure';
            stopMachine();
            return;
        }

        const currentSymbol = tape[headPosition] || 'O';
        const rule = getRule(state, currentSymbol);

        tape[headPosition] = rule.write;
        headPosition += rule.move === 'Right' ? 1 : -1;
        state = rule.next;
        steps++;

        document.getElementById('stepCount').textContent = steps;
        document.getElementById('currentState').textContent = state;
        updateTape(tape, headPosition);

        // Check win/loss conditions after the step's actions
        if (state === 'Stop') { // Machine was told to stop by the rule
            if (steps === maxSteps) {
                result.textContent = `Success! You slid exactly ${steps} time${steps !== 1 ? 's' : ''}.`;
                result.className = 'success';
            } else { // Stopped, but not at the target number of steps
                result.textContent = `Fail! You stopped at ${steps} slide${steps !== 1 ? 's' : ''}. Goal was ${maxSteps}.`;
                result.className = 'failure';
            }
            stopMachine();
            return;
        } else if (steps === maxSteps && state !== 'Stop') { // Reached target steps, but machine didn't stop
            result.textContent = `Fail! Machine did not stop after ${maxSteps} slide${maxSteps !== 1 ? 's' : ''}.`;
            result.className = 'failure';
            stopMachine();
            return;
        }
        machineTimeout = setTimeout(step, 350); 
      }
      step();
    }

    // Initialize when page loads
    window.onload = () => {
        const defaultLevel = 1; 
        const radio = document.querySelector(`input[name="level"][value="${defaultLevel}"]`);
        if (radio) {
            radio.checked = true;
        }
        setupGame(defaultLevel); 
    };
  </script>
</body>
</html>
