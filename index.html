<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Switch 'n Slide</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>Switch 'n Slide</h1>

    <div class="level-selector">
      <strong>Level:</strong>
      <label><input type="radio" name="level" value="1" onclick="setupGame(1)" checked> 1</label>
      <label><input type="radio" name="level" value="2" onclick="setupGame(2)"> 2</label>
      <label><input type="radio" name="level" value="3" onclick="setupGame(3)"> 3</label>
      <label><input type="radio" name="level" value="4" onclick="setupGame(4)"> 4</label>
      <label><input type="radio" name="level" value="5" onclick="setupGame(5)"> 5</label>
    </div>

    <p id="goal">Goal: Set instructions that slide the Cell Tape exactly N times.</p>

    <div class="rules-container">
      <div class="rule-header">Instructions:</div>
      <div id="rules"></div>
    </div>

    <div class="controls">
      <button onclick="runMachine()">Begin</button>
    </div>

    <div id="result"></div>
    <div class="step-counter">Slide Count: <span id="stepCount">0</span></div>
    <div class="state-indicator">Mode: <span id="currentState" class="current-state">A</span></div>
    
    <div class="tape-indicator">
      <div id="tape">
        <div id="tape-container" class="tape-container">
          <div id="tape-wrapper" class="tape-wrapper">
            <div id="tape-inner" class="tape-inner"></div>
          </div>
        </div>
      </div>    
    </div>

    <script>
      // --- Game Configuration ---
      let numStates = 2;
      let states = ['A', 'B'];
      let nextStateOptionsText = ['Yes', 'No', 'Stop'];
      let targetSteps = 2; // Default for new Level 1 (level 1 + 1)
      let currentLevel = 1; // Default to new Level 1
  
      const symbols = ['O', 'X'];
      const moveOptions = ['Left', 'Right']; // Not directly used for button cycle anymore for fixed ones
      const cellWidth = 28;
      const cellMargin = 2;
      const cellTotalWidth = cellWidth + cellMargin;
  
      let isRunning = false;
      let machineTimeout = null;
      let currentTape = {};
      let currentHeadPosition = 0;
  
      function setupGame(level) {
          stopMachine();
          currentLevel = level;
          targetSteps = level + 1; // New Level 1 -> 2 slides, Level 2 -> 3 slides, etc.
  
          const goalText = document.getElementById('goal');
          goalText.innerHTML = `Goal: Set instructions that slide the Cell Tape exactly ${targetSteps} times. <br>Cells are marked with X as you slide past.`;
  
          buildUI();
          initializeTape();
          resetMachine();
      }
  
      function buildUI() {
        const container = document.getElementById('rules');
        container.innerHTML = '';

        const table = document.createElement('table');
        table.className = 'rules-table';

        // Create header row
        const headerRow = document.createElement('tr');
        ['Mode | Cell', 'Slide', 'Switch'].forEach(headerText => {
          const th = document.createElement('th');
          th.textContent = headerText;
          headerRow.appendChild(th);
        });
        table.appendChild(headerRow);

        // Desired order: Tape O then Tape X, and within each: Mode A then Mode B
        const desiredOrder = [];
        for (const symbol of symbols) {
          for (const state of states) {
            desiredOrder.push({ state, symbol });
          }
        }

        for (const { state, symbol } of desiredOrder) {
          const row = document.createElement('tr');

          const conditionCell = document.createElement('td');
          conditionCell.textContent = `${state} | ${symbol}`;
          row.appendChild(conditionCell);

          const moveCell = document.createElement('td');
          const moveBtn = document.createElement('button');
          moveBtn.id = `${state}${symbol}-move`;
          moveCell.appendChild(moveBtn);
          row.appendChild(moveCell);

          const nextCell = document.createElement('td');
          const nextBtn = document.createElement('button');
          nextBtn.id = `${state}${symbol}-next`;
          nextCell.appendChild(nextBtn);
          row.appendChild(nextCell);

          // Logic for fixed/variable behavior
          if (state === 'A' && symbol === 'O') {
            moveBtn.textContent = 'Left';
            moveBtn.disabled = true;
            nextBtn.textContent = 'Yes';
            nextBtn.disabled = true;
          } else if (state === 'B' && symbol === 'O') {
            moveBtn.textContent = 'Right';
            moveBtn.disabled = true;

            let nextIndex = 0;
            nextBtn.textContent = nextStateOptionsText[nextIndex];
            nextBtn.onclick = () => {
              nextIndex = (nextIndex + 1) % nextStateOptionsText.length;
              nextBtn.textContent = nextStateOptionsText[nextIndex];
            };
          } else {
            moveBtn.textContent = 'Left';
            moveBtn.onclick = () => {
              moveBtn.textContent = moveBtn.textContent === 'Left' ? 'Right' : 'Left';
            };

            let nextIndex = 0;
            nextBtn.textContent = nextStateOptionsText[nextIndex];
            nextBtn.onclick = () => {
              nextIndex = (nextIndex + 1) % nextStateOptionsText.length;
              nextBtn.textContent = nextStateOptionsText[nextIndex];
            };
          }

          table.appendChild(row);
        }

        container.appendChild(table);
      }

  
      function getRule(state, symbol) {
        if (state === 'A' && symbol === 'O') {
          return { write: 'X', move: 'Left', next: 'B' }; // 'B' is the state after 'A'
        } else if (state === 'B' && symbol === 'O') {
          // Mode B, Tape O: Move is fixed to Right, Next is determined by its button
          const nextEl = document.getElementById(`BO-next`);
          if (!nextEl) {
            console.error(`Rule element BO-next not found`);
            return { write: 'X', move: 'Right', next: state }; // Fallback
          }
          let nextValText = nextEl.textContent;
          let resolvedNext;
          if (nextValText === 'Stop') {
            resolvedNext = 'Stop';
          } else if (nextValText === 'Yes') {
            resolvedNext = state === 'A' ? 'B' : 'A'; // If current is B, switch to A
          } else { // 'No'
            resolvedNext = state; // Stay in B
          }
          return { write: 'X', move: 'Right', next: resolvedNext };
        }

        // For fully editable rules
        const moveEl = document.getElementById(`${state}${symbol}-move`);
        const nextEl = document.getElementById(`${state}${symbol}-next`);
  
        if (!moveEl || !nextEl) {
            console.error(`Rule elements not found for state ${state}, symbol ${symbol}`);
            return { write: 'X', move: 'Right', next: state }; 
        }
  
        let nextValText = nextEl.textContent;
        let resolvedNext;
  
        if (nextValText === 'Stop') {
            resolvedNext = 'Stop';
        } else if (nextValText === 'Yes') {
            resolvedNext = state === 'A' ? 'B' : 'A';
        } else { // 'No'
           resolvedNext = state;
        }
  
        return { write: 'X', move: moveEl.textContent, next: resolvedNext };
      }

    // --- Tape Visualization ---
    function initializeTape() {
      const tapeContainer = document.getElementById('tape-container');
      const tapeWrapper = document.getElementById('tape-wrapper');
      const tapeInner = document.getElementById('tape-inner');

      if (!tapeContainer || !tapeWrapper || !tapeInner) {
          console.error("Tape elements not found during initialization!");
          return;
      }

      tapeInner.innerHTML = '';
      tapeInner.style.transform = 'translateX(0px)';

      const numVisibleCells = 7;
      const currentTargetSteps = 3;
      const tapeWidth = numVisibleCells * cellTotalWidth;

      tapeContainer.style.width = `${tapeWidth}px`;
      tapeWrapper.style.width = `${tapeWidth}px`;

      for (let i = 0; i < numVisibleCells; i++) {
        const cell = document.createElement('span');
        cell.className = 'cell';
        cell.textContent = 'O';
        cell.setAttribute('data-index', i - currentTargetSteps); // Center index around 0
        tapeInner.appendChild(cell);
      }
    }

    function updateTape(tape, headPosition) {
        const tapeWrapper = document.getElementById('tape-wrapper');
        const tapeInner = document.getElementById('tape-inner');

        if (!tapeWrapper || !tapeInner) {
          console.error("Tape elements not found during update!");
          return;
        }
        const cells = tapeInner.querySelectorAll('.cell');
        if (cells.length === 0) {
            console.error("No cells found to update!");
            return;
        }

        const tapeWidth = parseFloat(tapeWrapper.style.width);
        const visualCenter = tapeWidth / 2;
        
        const centerDataIndex = 0; // The logical center of our tape data
        // Find the DOM element that corresponds to the logical center data index, if it exists.
        // Or more simply, the middle DOM element.
        const centerCellDOMIndex = Math.floor(cells.length / 2);


        cells.forEach(cell => {
            cell.classList.remove('active');
            const logicalIndex = parseInt(cell.getAttribute('data-index'));
            const value = tape[logicalIndex] || 'O';
            cell.textContent = value;
        });

        let activeCellDOMIndex = -1;
        for (let i = 0; i < cells.length; i++) {
            const logicalIndex = parseInt(cells[i].getAttribute('data-index'));
            if (logicalIndex === headPosition) {
                cells[i].classList.add('active');
                activeCellDOMIndex = i;
                break;
            }
        }
        
        if (activeCellDOMIndex !== -1) {
            // Center based on the DOM position of the active cell
            const activeCellVisualCenter = activeCellDOMIndex * cellTotalWidth + (cellTotalWidth / 2);
            const offset = visualCenter - activeCellVisualCenter;
            tapeInner.style.transform = `translateX(${offset}px)`;
        } else {
            // Fallback: if active cell is not currently rendered (e.g. head moved off initial display)
            // This attempts to keep the tape somewhat centered based on headPosition's logical relation to the center.
            // This case implies the head is "off-screen" relative to current DOM cells.
            // A more robust solution for infinite tapes would dynamically add/remove cells.
            // For this game, headPosition should ideally stay within view based on targetSteps.
            const offsetBasedOnHead = visualCenter - ( (headPosition + centerCellDOMIndex - parseInt(cells[centerCellDOMIndex].getAttribute('data-index'))) * cellTotalWidth + (cellTotalWidth / 2) );
            tapeInner.style.transform = `translateX(${offsetBasedOnHead}px)`;
        }
    }

    // --- Machine Control ---
    function stopMachine() {
         if (machineTimeout) {
            clearTimeout(machineTimeout);
            machineTimeout = null;
         }
         isRunning = false;
    }

    function resetMachine() {
      stopMachine();
      currentTape = {};
      currentHeadPosition = 0;

      document.getElementById('currentState').textContent = 'A';
      document.getElementById('result').textContent = '';
      document.getElementById('result').className = '';
      document.getElementById('stepCount').textContent = '0';

      // initializeTape is called by setupGame. updateTape will render the reset state.
      if (document.getElementById('tape-inner')?.children.length > 0) {
           updateTape(currentTape, currentHeadPosition);
      } else {
           // This case should ideally not be hit if setupGame runs first
           initializeTape(); 
           setTimeout(() => updateTape(currentTape, currentHeadPosition), 0);
      }
    }

    function runMachine() {
      if (isRunning) return;
      // resetMachine() is implicitly called via setupGame() before a new run.
      isRunning = true;

      let tape = { ...currentTape }; 
      let headPosition = currentHeadPosition; 
      let state = 'A'; 
      let steps = 0;
      const maxSteps = targetSteps; 

      document.getElementById('currentState').textContent = state;
      document.getElementById('stepCount').textContent = steps;
      updateTape(tape, headPosition); 

      function step() {
        if (!isRunning) return;
        const result = document.getElementById('result');
        result.textContent = '';
        result.className = ''; // Remove success/failure class

        const currentSymbol = tape[headPosition] || 'O';
        const rule = getRule(state, currentSymbol);

        tape[headPosition] = rule.write;
        headPosition += rule.move === 'Right' ? 1 : -1;
        state = rule.next;
        steps++;

        document.getElementById('stepCount').textContent = steps;
        document.getElementById('currentState').textContent = state;
        updateTape(tape, headPosition);

        if (state === 'Stop') {
            if (steps === maxSteps) {
                result.textContent = `Success!`;
                result.className = 'success';
            } else {
                result.textContent = `Fail!`;
                result.className = 'failure';
            }
            stopMachine();
            return;
        }

        if (steps >= maxSteps) {
            result.textContent = `Fail!`;
            result.className = 'failure';
            stopMachine();
            return;
        }

        machineTimeout = setTimeout(step, 350);
    }
    step();

    }

    // Initialize when page loads
    window.onload = () => {
        const defaultLevel = 1; 
        const radio = document.querySelector(`input[name="level"][value="${defaultLevel}"]`);
        if (radio) {
            radio.checked = true;
        }
        setupGame(defaultLevel); 
    };
  </script>
</body>
</html>